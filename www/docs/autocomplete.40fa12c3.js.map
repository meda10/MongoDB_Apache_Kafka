{"version":3,"sources":["js/autocomplete.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","autocomplete","settings","doc","selected","debounceTimer","document","container","createElement","containerStyle","style","userAgent","navigator","mobileFirefox","indexOf","debounceWaitMs","preventSubmit","disableAutoSelect","keyUpEventName","items","inputValue","minLen","showOnFocus","keypressCounter","undefined","minLength","input","Error","clearDebounceTimer","window","clearTimeout","containerDisplayed","parentNode","clear","detach","parent","removeChild","update","firstChild","render","item","currentValue","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","updatePosition","height","width","offsetWidth","maxHeight","inputRect","calc","customize","docEl","documentElement","clientTop","clientLeft","scrollTop","pageYOffset","scrollLeft","pageXOffset","top","getBoundingClientRect","offsetHeight","left","innerHeight","bottom","updateScroll","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","selectBottom","containerBottom","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","keyCode","which","_i","ignore_1","startFetch","keydownEventHandler","containerIsDisplayed","selectPrev","i","selectNext","focusEventHandler","trigger","savedKeypressCounter","val","value","setTimeout","fetch","blurEventHandler","activeElement","position","evt","focus","destroy","removeEventListener"],"mappings":"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","file":"autocomplete.40fa12c3.js","sourceRoot":"..","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.autocomplete = factory());\n}(this, (function () { 'use strict';\n\n  /*\n   * https://github.com/kraaden/autocomplete\n   * Copyright (c) 2016 Denys Krasnoshchok\n   * MIT License\n   */\n  function autocomplete(settings) {\n      // just an alias to minimize JS file size\n      var doc = document;\n      var container = settings.container || doc.createElement(\"div\");\n      var containerStyle = container.style;\n      var userAgent = navigator.userAgent;\n      var mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\n      var debounceWaitMs = settings.debounceWaitMs || 0;\n      var preventSubmit = settings.preventSubmit || false;\n      var disableAutoSelect = settings.disableAutoSelect || false;\n      // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n      var keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n      var items = [];\n      var inputValue = \"\";\n      var minLen = 2;\n      var showOnFocus = settings.showOnFocus;\n      var selected;\n      var keypressCounter = 0;\n      var debounceTimer;\n      if (settings.minLength !== undefined) {\n          minLen = settings.minLength;\n      }\n      if (!settings.input) {\n          throw new Error(\"input undefined\");\n      }\n      var input = settings.input;\n      container.className = \"autocomplete \" + (settings.className || \"\");\n      // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n      containerStyle.position = \"absolute\";\n      /**\n       * Detach the container from DOM\n       */\n      function detach() {\n          var parent = container.parentNode;\n          if (parent) {\n              parent.removeChild(container);\n          }\n      }\n      /**\n       * Clear debouncing timer if assigned\n       */\n      function clearDebounceTimer() {\n          if (debounceTimer) {\n              window.clearTimeout(debounceTimer);\n          }\n      }\n      /**\n       * Attach the container to DOM\n       */\n      function attach() {\n          if (!container.parentNode) {\n              doc.body.appendChild(container);\n          }\n      }\n      /**\n       * Check if container for autocomplete is displayed\n       */\n      function containerDisplayed() {\n          return !!container.parentNode;\n      }\n      /**\n       * Clear autocomplete state and hide container\n       */\n      function clear() {\n          // prevent the update call if there are pending AJAX requests\n          keypressCounter++;\n          items = [];\n          inputValue = \"\";\n          selected = undefined;\n          detach();\n      }\n      /**\n       * Update autocomplete position\n       */\n      function updatePosition() {\n          if (!containerDisplayed()) {\n              return;\n          }\n          containerStyle.height = \"auto\";\n          containerStyle.width = input.offsetWidth + \"px\";\n          var maxHeight = 0;\n          var inputRect;\n          function calc() {\n              var docEl = doc.documentElement;\n              var clientTop = docEl.clientTop || doc.body.clientTop || 0;\n              var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n              var scrollTop = window.pageYOffset || docEl.scrollTop;\n              var scrollLeft = window.pageXOffset || docEl.scrollLeft;\n              inputRect = input.getBoundingClientRect();\n              var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n              var left = inputRect.left + scrollLeft - clientLeft;\n              containerStyle.top = top + \"px\";\n              containerStyle.left = left + \"px\";\n              maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n              if (maxHeight < 0) {\n                  maxHeight = 0;\n              }\n              containerStyle.top = top + \"px\";\n              containerStyle.bottom = \"\";\n              containerStyle.left = left + \"px\";\n              containerStyle.maxHeight = maxHeight + \"px\";\n          }\n          // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n          calc();\n          calc();\n          if (settings.customize && inputRect) {\n              settings.customize(input, inputRect, container, maxHeight);\n          }\n      }\n      /**\n       * Redraw the autocomplete div element with suggestions\n       */\n      function update() {\n          // delete all children from autocomplete DOM container\n          while (container.firstChild) {\n              container.removeChild(container.firstChild);\n          }\n          // function for rendering autocomplete suggestions\n          var render = function (item, currentValue) {\n              var itemElement = doc.createElement(\"div\");\n              itemElement.textContent = item.label || \"\";\n              return itemElement;\n          };\n          if (settings.render) {\n              render = settings.render;\n          }\n          // function to render autocomplete groups\n          var renderGroup = function (groupName, currentValue) {\n              var groupDiv = doc.createElement(\"div\");\n              groupDiv.textContent = groupName;\n              return groupDiv;\n          };\n          if (settings.renderGroup) {\n              renderGroup = settings.renderGroup;\n          }\n          var fragment = doc.createDocumentFragment();\n          var prevGroup = \"#9?$\";\n          items.forEach(function (item) {\n              if (item.group && item.group !== prevGroup) {\n                  prevGroup = item.group;\n                  var groupDiv = renderGroup(item.group, inputValue);\n                  if (groupDiv) {\n                      groupDiv.className += \" group\";\n                      fragment.appendChild(groupDiv);\n                  }\n              }\n              var div = render(item, inputValue);\n              if (div) {\n                  div.addEventListener(\"click\", function (ev) {\n                      settings.onSelect(item, input);\n                      clear();\n                      ev.preventDefault();\n                      ev.stopPropagation();\n                  });\n                  if (item === selected) {\n                      div.className += \" selected\";\n                  }\n                  fragment.appendChild(div);\n              }\n          });\n          container.appendChild(fragment);\n          if (items.length < 1) {\n              if (settings.emptyMsg) {\n                  var empty = doc.createElement(\"div\");\n                  empty.className = \"empty\";\n                  empty.textContent = settings.emptyMsg;\n                  container.appendChild(empty);\n              }\n              else {\n                  clear();\n                  return;\n              }\n          }\n          attach();\n          updatePosition();\n          updateScroll();\n      }\n      function updateIfDisplayed() {\n          if (containerDisplayed()) {\n              update();\n          }\n      }\n      function resizeEventHandler() {\n          updateIfDisplayed();\n      }\n      function scrollEventHandler(e) {\n          if (e.target !== container) {\n              updateIfDisplayed();\n          }\n          else {\n              e.preventDefault();\n          }\n      }\n      function keyupEventHandler(ev) {\n          var keyCode = ev.which || ev.keyCode || 0;\n          var ignore = [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\n          for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\n              var key = ignore_1[_i];\n              if (keyCode === key) {\n                  return;\n              }\n          }\n          if (keyCode >= 112 /* F1 */ && keyCode <= 123 /* F12 */) {\n              return;\n          }\n          // the down key is used to open autocomplete\n          if (keyCode === 40 /* Down */ && containerDisplayed()) {\n              return;\n          }\n          startFetch(0 /* Keyboard */);\n      }\n      /**\n       * Automatically move scroll bar if selected item is not visible\n       */\n      function updateScroll() {\n          var elements = container.getElementsByClassName(\"selected\");\n          if (elements.length > 0) {\n              var element = elements[0];\n              // make group visible\n              var previous = element.previousElementSibling;\n              if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n                  element = previous;\n              }\n              if (element.offsetTop < container.scrollTop) {\n                  container.scrollTop = element.offsetTop;\n              }\n              else {\n                  var selectBottom = element.offsetTop + element.offsetHeight;\n                  var containerBottom = container.scrollTop + container.offsetHeight;\n                  if (selectBottom > containerBottom) {\n                      container.scrollTop += selectBottom - containerBottom;\n                  }\n              }\n          }\n      }\n      /**\n       * Select the previous item in suggestions\n       */\n      function selectPrev() {\n          if (items.length < 1) {\n              selected = undefined;\n          }\n          else {\n              if (selected === items[0]) {\n                  selected = items[items.length - 1];\n              }\n              else {\n                  for (var i = items.length - 1; i > 0; i--) {\n                      if (selected === items[i] || i === 1) {\n                          selected = items[i - 1];\n                          break;\n                      }\n                  }\n              }\n          }\n      }\n      /**\n       * Select the next item in suggestions\n       */\n      function selectNext() {\n          if (items.length < 1) {\n              selected = undefined;\n          }\n          if (!selected || selected === items[items.length - 1]) {\n              selected = items[0];\n              return;\n          }\n          for (var i = 0; i < (items.length - 1); i++) {\n              if (selected === items[i]) {\n                  selected = items[i + 1];\n                  break;\n              }\n          }\n      }\n      function keydownEventHandler(ev) {\n          var keyCode = ev.which || ev.keyCode || 0;\n          if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\n              var containerIsDisplayed = containerDisplayed();\n              if (keyCode === 27 /* Esc */) {\n                  clear();\n              }\n              else {\n                  if (!containerIsDisplayed || items.length < 1) {\n                      return;\n                  }\n                  keyCode === 38 /* Up */\n                      ? selectPrev()\n                      : selectNext();\n                  update();\n              }\n              ev.preventDefault();\n              if (containerIsDisplayed) {\n                  ev.stopPropagation();\n              }\n              return;\n          }\n          if (keyCode === 13 /* Enter */) {\n              if (selected) {\n                  settings.onSelect(selected, input);\n                  clear();\n              }\n              if (preventSubmit) {\n                  ev.preventDefault();\n              }\n          }\n      }\n      function focusEventHandler() {\n          if (showOnFocus) {\n              startFetch(1 /* Focus */);\n          }\n      }\n      function startFetch(trigger) {\n          // If multiple keys were pressed, before we get an update from server,\n          // this may cause redrawing autocomplete multiple times after the last key was pressed.\n          // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\n          var savedKeypressCounter = ++keypressCounter;\n          var val = input.value;\n          if (val.length >= minLen || trigger === 1 /* Focus */) {\n              clearDebounceTimer();\n              debounceTimer = window.setTimeout(function () {\n                  settings.fetch(val, function (elements) {\n                      if (keypressCounter === savedKeypressCounter && elements) {\n                          items = elements;\n                          inputValue = val;\n                          selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];\n                          update();\n                      }\n                  }, trigger);\n              }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);\n          }\n          else {\n              clear();\n          }\n      }\n      function blurEventHandler() {\n          // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n          setTimeout(function () {\n              if (doc.activeElement !== input) {\n                  clear();\n              }\n          }, 200);\n      }\n      /**\n       * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\n       */\n      container.addEventListener(\"mousedown\", function (evt) {\n          evt.stopPropagation();\n          evt.preventDefault();\n      });\n      /**\n       * Fixes #30: autocomplete closes when scrollbar is clicked in IE\n       * See: https://stackoverflow.com/a/9210267/13172349\n       */\n      container.addEventListener(\"focus\", function () { return input.focus(); });\n      /**\n       * This function will remove DOM elements and clear event handlers\n       */\n      function destroy() {\n          input.removeEventListener(\"focus\", focusEventHandler);\n          input.removeEventListener(\"keydown\", keydownEventHandler);\n          input.removeEventListener(keyUpEventName, keyupEventHandler);\n          input.removeEventListener(\"blur\", blurEventHandler);\n          window.removeEventListener(\"resize\", resizeEventHandler);\n          doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n          clearDebounceTimer();\n          clear();\n      }\n      // setup event handlers\n      input.addEventListener(\"keydown\", keydownEventHandler);\n      input.addEventListener(keyUpEventName, keyupEventHandler);\n      input.addEventListener(\"blur\", blurEventHandler);\n      input.addEventListener(\"focus\", focusEventHandler);\n      window.addEventListener(\"resize\", resizeEventHandler);\n      doc.addEventListener(\"scroll\", scrollEventHandler, true);\n      return {\n          destroy: destroy\n      };\n  }\n\n  return autocomplete;\n\n})));\n\n"]}